#!/usr/bin/env cbqn
lib â† â€¢Import "lib.bqn"

# backward operations are mapped to `â¼`
NewVariable â‡ {
  gradâ€¿input â‡ 1â€¿ğ•©
  Val â‡ { S n: input; Sâ¼ n: grad }
  Set â‡ { S ğ•©: input â†© ğ•©; Sâ¼ ğ•©: grad â†© ğ•© }
}

_function_ â‡ {
  Fwdâ€¿Bckâ€¿input â‡ ğ”½â€¿ğ”¾â€¿Â¯âˆ
  Set â‡ { S ğ•©: Fwd â†© ğ•; Sâ¼ x: Bck â†© ğ• }
  Propagate â‡ {
      S  ğ•©: input â†© ğ•©, NewVariable Fwd ğ•©.Val @;
      Sâ¼ ğ•©: (ğ•©.Valâ¼ @) Ã— Bck input.Val @;
    v Sâ¼ ğ•©: v.Setâ¼ (ğ•©.Valâ¼ @) Ã— Bck input.Val @, v
  }
  NumericalDiff â‡ { Diff x: 0.0001 Diff x; e Diff x: x.input (+((2Ã—e)âŠ¸(Ã·Ëœ)âˆ˜-â—‹Fwd)-) e }
}

_asFunction â‡ { ğ”½ _function_ { F ğ•©: !ğ•©â‰ ğ•© }  }
_followedBy_ â‡ { ğ•˜.Fwdâˆ˜ğ•—.Fwd _asFunction }

# some function examples
Square â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
Exp â† â‹†_function_â‹†
Ln â† â‹†â¼_function_ (Ã·Ëœ)

# composited functions
F â† Exp _followedBy_ Ln
G â† Square _followedBy_ Square
Chain â† Square _followedBy_ Exp _followedBy_ Square

x â† NewVariable 0
x10 â† NewVariable 10

"Square x10"                 lib.Debug (square.Propagate x10).Val @
"Exp x"                      lib.Debug (exp.Propagate x).Val @
"Ln x10"                     lib.Debug (ln.Propagate x10).Val @
"Lnâˆ˜Exp x10"                 lib.Debug (f.Propagate x10).Val @
"Squareâˆ˜Square x10"          lib.Debug (g.Propagate x10).Val @
"Aâˆ˜Bâˆ˜C 0.5 should be 1.648"  lib.Debug (chain.Propagate NewVariable 0.5).Val @
"num. diff of Square at 2.0" lib.Debug square.NumericalDiff NewVariable 2
"num. diff of Aâˆ˜Bâˆ˜C at 0.5"  lib.Debug chain.NumericalDiff NewVariable 0.5

## step 6.4
FA â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
FB â† â‹†_function_â‹†
FC â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
x â†© NewVariable 0.5
y â† fc.Propagate b â† fb.Propagate a â† fa.Propagate x
x fa.Propagateâ¼ a fb.Propagateâ¼ b fc.Propagateâ¼ y
"back prop. Câ†’Bâ†’A at 0.5" lib.Debug x.Valâ¼ @
