#!/usr/bin/env cbqn
lib â† â€¢Import "lib.bqn"

# backward operations are mapped to `â¼`
NewVariable â‡ {
    F ğ•©: âˆ F ğ•©;
  c F ğ•©:
    gradâ€¿inputâ€¿creator â‡ 1â€¿ğ•©â€¿c
    Val â‡ {
      S  n: input;
      Sâ¼ n: grad
    }
    Set â‡ {
      S  ğ•©: input â†© ğ•©;
      Sâ¼ ğ•©: grad â†© ğ•©
    }
}

_functionBuilder_ â‡ {
  Self â‡ { self â†© ğ•© }
  Fwdâ€¿Bckâ€¿inputâ€¿output â‡ ğ”½â€¿ğ”¾â€¿Â¯âˆâ€¿âˆ
  Set â‡ {
    S  ğ•©: Fwd â†© ğ•;
    Sâ¼ x: Bck â†© ğ•
  }
  Propagate â‡ {
      S  ğ•©: input â†© ğ•©, output â†© self NewVariable Fwd ğ•©.Val @;
      Sâ¼ ğ•©: (ğ•©.Valâ¼ @) Ã— Bck input.Val @;
    v Sâ¼ ğ•©: v.Setâ¼ (ğ•©.Valâ¼ @) Ã— Bck input.Val @, v
  }
  BackPropagate â‡ {
      Rec ğ•©: input.creator Rec self;
    âˆ Rec f:
      f.input f.Propagateâ¼ f.output
      f.input.grad;
    c Rec f:
      c.output f.Propagateâ¼ f.output
      ! c.output.grad=f.input.grad
      c.input.creator Rec c
  }
  NumericalDiff â‡ {
      Diff x: 0.0001 Diff x;
    e Diff x: x.input (+((2Ã—e)âŠ¸(Ã·Ëœ)âˆ˜-â—‹Fwd)-) e
  }
}

_function_ â‡ { C â† ğ”½ _functionBuilder_ ğ”¾, c.Self c }
_asFunction â‡ { ğ”½ _function_ { F ğ•©: !ğ•©â‰ ğ•© }  }
_followedBy_ â‡ { ğ•˜.Fwdâˆ˜ğ•—.Fwd _asFunction }

# some function examples
Square â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
Exp â† â‹†_function_â‹†
Ln â† â‹†â¼_function_ (Ã·Ëœ)
# composited functions
F â† Exp _followedBy_ Ln
G â† Square _followedBy_ Square
Chain â† Square _followedBy_ Exp _followedBy_ Square

# variables
x â† NewVariable 0
x10 â† NewVariable 10

"(Step02)Square x10 returns"         lib.Debug (square.Propagate x10).Val @
"(Step02)Exp x returns"              lib.Debug (exp.Propagate x).Val @
"(Step02)Ln x10 returns"             lib.Debug (ln.Propagate x10).Val @
"(Step02)Lnâˆ˜Exp x10 returns"         lib.Debug (f.Propagate x10).Val @
"(Step03)Squareâˆ˜Square x10"          lib.Debug (g.Propagate x10).Val @
"(Step03)Aâˆ˜Bâˆ˜C 0.5 should be 1.648"  lib.Debug (chain.Propagate NewVariable 0.5).Val @
"(Step04)num. diff of Square at 2.0" lib.Debug square.NumericalDiff NewVariable 2
"(Step04)num. diff of Aâˆ˜Bâˆ˜C at 0.5"  lib.Debug chain.NumericalDiff NewVariable 0.5
## step 6.4
F06A â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
F06B â† â‹†_function_â‹†
F06C â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
x06 â† NewVariable 0.5
y06 â† f06c.Propagate b06 â† f06b.Propagate a06 â† f06a.Propagate x06
x06 f06a.Propagateâ¼ a06 f06b.Propagateâ¼ b06 f06c.Propagateâ¼ y06
"(Step06)back prop. Câ†’Bâ†’A at 0.5"    lib.Debug x06.Valâ¼ @
## step 7
"(Step07)Each function has self"     lib.Debug square=square.self
F07A â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
F07B â† â‹†_function_â‹†
F07C â† 2âŠ¸(â‹†Ëœ) _function_ (2âŠ¸Ã—)
x07 â† NewVariable 0.5
y07 â† f07C.Propagate b07 â† f07B.Propagate a07 â† f07A.Propagate x07
f07c.BackPropagate @
"(Step07)auto back prop chain"       lib.Debug x07.Valâ¼ @
